{"version":3,"sources":["updateHandlers.ts"],"names":["registerHandler","RNGestureHandlerModule","filterConfig","scheduleFlushOperations","ghQueueMicrotask","extractGestureRelations","checkGestureCallbacksForWorklets","ALLOWED_PROPS","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","handlerTag","handlers","isMounted","config","updateGestureHandler","testId","animatedHandlers","previousHandlersValue","value","newHandlersValue","filter","g","shouldUseReanimated","map","shouldUpdateSharedValue","gestureId"],"mappings":"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","sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport {\n  filterConfig,\n  scheduleFlushOperations,\n} from '../../gestureHandlerCommon';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      const previousHandlersValue =\n        preparedGesture.animatedHandlers.value ?? [];\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      // if amount of gesture configs changes, we need to update the callbacks in shared value\n      let shouldUpdateSharedValue =\n        previousHandlersValue.length !== newHandlersValue.length;\n\n      if (!shouldUpdateSharedValue) {\n        // if the amount is the same, we need to check if any of the configs inside has changed\n        for (let i = 0; i < newHandlersValue.length; i++) {\n          if (\n            // we can use the `gestureId` prop as it's unique for every config instance\n            newHandlersValue[i].gestureId !== previousHandlersValue[i].gestureId\n          ) {\n            shouldUpdateSharedValue = true;\n            break;\n          }\n        }\n      }\n\n      if (shouldUpdateSharedValue) {\n        preparedGesture.animatedHandlers.value = newHandlersValue;\n      }\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"]}