{"version":3,"sources":["useDetectorUpdater.ts"],"names":["useDetectorUpdater","state","preparedGesture","gesturesToAttach","gestureConfig","webEventHandlersRef","forceRender","updateAttachedGestures","skipConfigUpdate","viewTag","viewRef","didUnderlyingViewChange","previousViewTag","forceRebuildReanimatedEvent"],"mappings":";;;;;;;AAAA;;AACA;;AASA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACO,SAASA,kBAAT,CACLC,KADK,EAELC,eAFK,EAGLC,gBAHK,EAILC,aAJK,EAKLC,mBALK,EAML;AACA,QAAMC,WAAW,GAAG,4BAApB;AACA,QAAMC,sBAAsB,GAAG,yBAC7B;AACCC,EAAAA,gBAAD,IAAgC;AAC9B;AACA,UAAMC,OAAO,GAAG,iCAAeR,KAAK,CAACS,OAArB,CAAhB;AACA,UAAMC,uBAAuB,GAAGF,OAAO,KAAKR,KAAK,CAACW,eAAlD;;AAEA,QACED,uBAAuB,IACvB,sCAAgBT,eAAhB,EAAiCC,gBAAjC,CAFF,EAGE;AACA,2CAAyBF,KAAK,CAACS,OAA/B;AACA,sCAAaR,eAAb;AACA,0CAAe;AACbA,QAAAA,eADa;AAEbE,QAAAA,aAFa;AAGbD,QAAAA,gBAHa;AAIbE,QAAAA,mBAJa;AAKbI,QAAAA;AALa,OAAf;;AAQA,UAAIE,uBAAJ,EAA6B;AAC3BV,QAAAA,KAAK,CAACW,eAAN,GAAwBH,OAAxB;AACAR,QAAAA,KAAK,CAACY,2BAAN,GAAoC,IAApC;AACAP,QAAAA,WAAW;AACZ;AACF,KAnBD,MAmBO,IAAI,CAACE,gBAAL,EAAuB;AAC5B,0CAAeN,eAAf,EAAgCE,aAAhC,EAA+CD,gBAA/C;AACD;AACF,GA7B4B,EA8B7B,CACEG,WADF,EAEEF,aAFF,EAGED,gBAHF,EAIED,eAJF,EAKED,KALF,EAMEI,mBANF,CA9B6B,CAA/B;AAwCA,SAAOE,sBAAP;AACD","sourcesContent":["import React, { useCallback } from 'react';\nimport { findNodeHandle } from 'react-native';\nimport { GestureType } from '../gesture';\nimport { ComposedGesture } from '../gestureComposition';\n\nimport {\n  AttachedGestureState,\n  GestureDetectorState,\n  WebEventHandler,\n} from './types';\nimport { attachHandlers } from './attachHandlers';\nimport { updateHandlers } from './updateHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useForceRender, validateDetectorChildren } from './utils';\n\n// Returns a function that's responsible for updating the attached gestures\n// If the view has changed, it will reattach the handlers to the new view\n// If the view remains the same, it will update the handlers with the new config\nexport function useDetectorUpdater(\n  state: GestureDetectorState,\n  preparedGesture: AttachedGestureState,\n  gesturesToAttach: GestureType[],\n  gestureConfig: ComposedGesture | GestureType,\n  webEventHandlersRef: React.RefObject<WebEventHandler>\n) {\n  const forceRender = useForceRender();\n  const updateAttachedGestures = useCallback(\n    // skipConfigUpdate is used to prevent unnecessary updates when only checking if the view has changed\n    (skipConfigUpdate?: boolean) => {\n      // if the underlying view has changed we need to reattach handlers to the new view\n      const viewTag = findNodeHandle(state.viewRef) as number;\n      const didUnderlyingViewChange = viewTag !== state.previousViewTag;\n\n      if (\n        didUnderlyingViewChange ||\n        needsToReattach(preparedGesture, gesturesToAttach)\n      ) {\n        validateDetectorChildren(state.viewRef);\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesturesToAttach,\n          webEventHandlersRef,\n          viewTag,\n        });\n\n        if (didUnderlyingViewChange) {\n          state.previousViewTag = viewTag;\n          state.forceRebuildReanimatedEvent = true;\n          forceRender();\n        }\n      } else if (!skipConfigUpdate) {\n        updateHandlers(preparedGesture, gestureConfig, gesturesToAttach);\n      }\n    },\n    [\n      forceRender,\n      gestureConfig,\n      gesturesToAttach,\n      preparedGesture,\n      state,\n      webEventHandlersRef,\n    ]\n  );\n\n  return updateAttachedGestures;\n}\n"]}